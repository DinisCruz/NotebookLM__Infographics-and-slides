# Html_MGraph Performance Optimization Summary

**version**: v1.4.21
**Date**: December 29, 2025  
**Optimization Period**: November 27 - November 29, 2025  
**Primary Change**: Introduction of `Type_Safe__On_Demand` for lazy object initialization

---

## Executive Summary

Through systematic profiling and targeted optimization of the `Type_Safe` object initialization patterns, we achieved a **31% reduction in total execution time** for HTML-to-Graph conversion, with some individual operations improving by up to **70%**.

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| **Size=30 total time** | 441.79ms | 304.21ms | **-31%** |
| **Size=1 total time** | 121.5ms | 36.3ms | **-70%** |
| **MGraph__Index construction** | 1.9ms | 50µs | **-97%** |

---

## The Problem Identified

### Root Cause: Type_Safe Object Construction Overhead

When creating `MGraph__Index` objects, the `Type_Safe` base class automatically initialized all nested Type_Safe attributes recursively. For `MGraph__Index`, this created **100+ nested objects** on every construction—most of which were immediately discarded when references were rewired.

**Before optimization:**
```
MGraph__Index() construction: ~1.9ms
× 6 subgraphs per document = ~11.4ms
Just for empty index objects!
```

### Impact on HTML Processing

Every HTML element processed required index access, triggering this expensive construction chain. The `.index()` calls alone consumed **31% of total processing time** (14.2ms of 45.3ms for a simple HTML document).

---

## The Solution: Type_Safe__On_Demand

### What Changed

Introduced `Type_Safe__On_Demand`, a new base class that defers attribute initialization until first access:

```python
# Before: All attributes created immediately
class MGraph__Index(Type_Safe):
    edges_index: MGraph__Index__Edges  # Created on __init__
    
# After: Attributes created on first access
class MGraph__Index(Type_Safe__On_Demand):
    edges_index: MGraph__Index__Edges  # Created when accessed
```

### Classes Updated

The following classes were converted to use `Type_Safe__On_Demand`:

**Index Layer:**
- `MGraph__Index`
- `Schema__MGraph__Index__Data`
- `Schema__MGraph__Index__Data__Edges`
- `Schema__MGraph__Index__Data__Labels`
- `Schema__MGraph__Index__Data__Paths`
- `Schema__MGraph__Index__Data__Types`

**Supporting Indexes:**
- `MGraph__Index__Edges`
- `MGraph__Index__Labels`
- `MGraph__Index__Paths`
- `MGraph__Index__Types`
- `MGraph__Index__Values`

---

## Performance Results

### Size=30 Document Comparison (Apples to Apples)

Both runs: **4,322 calls** (identical workload)

| Frame | Before (27 Nov) | After (29 Nov) | Improvement |
|-------|-----------------|----------------|-------------|
| `process_body_children` | 904.2ms | 636.6ms | -30% |
| `_process_body__element` | 873.3ms | 614.3ms | -30% |
| `execute_pipeline` | 441.8ms | 304.2ms | -31% |
| `html_mgraph.convert.to-document` | 414.1ms | 287.7ms | -31% |
| `html_mgraph.convert.from-dict` | 413.4ms | 287.2ms | -31% |
| `html_mgraph.body.process` | 378.0ms | 266.2ms | -30% |
| `_process_body__register_attrs` | 294.9ms | 206.8ms | -30% |
| `add_attribute` | 252.8ms | 177.5ms | -30% |
| `new_node (mgraph_edit)` | 148.2ms | 100.8ms | -32% |
| `new_value` | 59.1ms | 43.5ms | -26% |
| `_get_or_create_value_node` | 51.9ms | 36.9ms | -29% |
| `register_element` | 50.5ms | 36.4ms | -28% |
| `mgraph_node` | 46.5ms | 29.9ms | **-36%** |
| `new_element_node` | 44.9ms | 31.8ms | -29% |
| `new_edge 1` | 40.9ms | 28.7ms | -30% |
| `new_edge 2` | 39.8ms | 28.0ms | -29% |
| `new_edge 3` | 39.4ms | 28.0ms | -29% |

### Scaling Comparison

| Size | Before | After | Speedup |
|------|--------|-------|---------|
| simple-html | 45.3ms | 22.4ms | 2.0× |
| size=1 | 121.5ms | 36.3ms | 3.3× |
| size=10 | ~350ms | 113.2ms | 3.1× |
| size=30 | 441.8ms | 304.2ms | 1.5× |

### Per-Call Improvements

| Operation | Before | After | Change |
|-----------|--------|-------|--------|
| `MGraph__Index()` | 1.9ms | 50µs | -97% |
| `new_node (model_mgraph)` | 0.31ms | 0.11ms | -65% |
| `.index()` first call | 2.5ms | 0.6ms | -76% |
| `add_attribute` | 4.2ms | 1.4ms | -67% |

---

## Key Insights

### 1. Construction vs Work Ratio

Before optimization, the ratio of object construction time to actual work was **73:1** for index operations. After optimization, this dropped to approximately **2:1**.

### 2. Fixed Costs Now Amortize Properly

The `document.setup` phase is now constant regardless of document size:

| Size | document.setup |
|------|----------------|
| 1 | 54.4ms |
| 10 | 53.5ms |
| 30 | 52.7ms |

### 3. Linear Scaling Confirmed

The `_process_body__element` time scales linearly with document size, as expected for O(n) processing.

---

## Architectural Changes

### Before: Eager Initialization
```
MGraph__Index.__init__()
├── Creates Schema__MGraph__Index__Data
│   ├── Creates Schema__MGraph__Index__Data__Edges
│   ├── Creates Schema__MGraph__Index__Data__Labels
│   └── ... (all sub-schemas)
├── Creates MGraph__Index__Edges
├── Creates MGraph__Index__Edit
│   ├── Creates its own MGraph__Index__Edges (duplicate!)
│   └── ... (more duplicates)
└── _sync_index_data() rewires references (discarding duplicates)
```

### After: Lazy Initialization
```
MGraph__Index.__init__()
└── (nothing created yet)

# Later, on first access:
index.edges_index  →  Creates MGraph__Index__Edges (once)
index.edit_index   →  Creates MGraph__Index__Edit
                      (uses shared edges_index via wiring)
```

---

## Profiling Methodology

### Tools Used
- Custom `@timestamp` decorator for method-level timing
- Speedscope for flame graph visualization
- Profile Analyzer UI for comparison views
- `Perf` utility for micro-benchmarks

### Test Cases
- `simple-html`: `<html><body><div class="main" id="content">Hello World</div></body></html>`
- `with_size__N`: Generated HTML with N repeated div elements

---

## Future Optimization Opportunities

### 1. Flatten Delegation Chains
The `add_attribute` → `_get_or_create_value_node` → `new_value_node` → `new_value` → `new_node` chain is 6 levels deep. Flattening could save function call overhead.

### 2. Batch Edge Creation
Each attribute creates 3 separate edges. A batch API could reduce overhead:
```python
# Current: 3 calls
new_edge(element, name_node)
new_edge(name_node, value_node)  
new_edge(element, value_node)

# Potential: 1 call
new_edges([(element, name_node), (name_node, value_node), (element, value_node)])
```

### 3. Reduce Index Wiring Overhead
The `_sync_index_data()` still triggers some object creation. Further lazy wiring could help.

### 4. Node Schema Optimization
The `new_node (model_mgraph)` method has complex conditional logic that could be simplified or cached.

---

## Conclusion

The introduction of `Type_Safe__On_Demand` successfully addressed the core performance bottleneck in the Html_MGraph conversion pipeline. By deferring object construction until first use, we eliminated wasteful creation of duplicate objects and reduced the per-operation overhead across the board.

**Key Achievement**: A complex HTML document (size=30) now processes in **304ms instead of 442ms** — a **31% improvement** with identical functionality and no breaking changes to the API.

---

## Files Changed

```
mgraph_db/mgraph/index/MGraph__Index.py
mgraph_db/mgraph/index/MGraph__Index__Edges.py
mgraph_db/mgraph/index/MGraph__Index__Labels.py
mgraph_db/mgraph/index/MGraph__Index__Paths.py
mgraph_db/mgraph/index/MGraph__Index__Types.py
mgraph_db/mgraph/index/MGraph__Index__Values.py
mgraph_db/mgraph/schemas/index/Schema__MGraph__Index__Data.py
mgraph_db/mgraph/schemas/index/Schema__MGraph__Index__Data__Edges.py
mgraph_db/mgraph/schemas/index/Schema__MGraph__Index__Data__Labels.py
mgraph_db/mgraph/schemas/index/Schema__MGraph__Index__Data__Paths.py
mgraph_db/mgraph/schemas/index/Schema__MGraph__Index__Data__Types.py
osbot_utils/type_safe/Type_Safe__On_Demand.py (new)
```

---

*This optimization was identified through systematic flame graph analysis and micro-benchmarking, demonstrating the value of comprehensive profiling infrastructure.*
