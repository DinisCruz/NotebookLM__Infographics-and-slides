# LLM Brief: LETS Pipeline Refactoring to Flow/Task Architecture

**Version**: v1.4.44  
**Date**: January 2025  
**Package**: `mgraph_ai_service_html_graph.service.lets_pipeline`  
**Dependencies**: `osbot_utils.helpers.flows` (Flow/Task system)

---

## Executive Summary

This brief describes the refactoring of the LETS (Load-Extract-Transform-Save) pipeline system to leverage the existing Flow/Task orchestration framework from `osbot_utils`. The refactoring introduces:

1. **Reusable Actions** - Individual L-E-T-S phases as `@task()` decorated functions
2. **Declarative Steps** - LETS steps wire actions via class attributes
3. **Type-Safe Dependency Injection** - Custom `task_dependencies()` method for typed context
4. **Standardized Execution** - Common `execute()` method in base class

---

## Part 1: Changes to osbot_utils (Flow/Task System)

### 1.1 Modification to Flow Class

**File**: `osbot_utils/helpers/flows/Flow.py`

Add a new method that subclasses can override to provide additional injectable dependencies for tasks:

```python
class Flow(Type_Safe):
    # ... existing code ...
    
    def task_dependencies(self) -> dict:
        """Override in subclasses to provide additional dependencies for task injection.
        
        Returns a dict mapping parameter names to values that will be auto-injected
        into @task() decorated functions when they request these parameters.
        
        Example:
            def task_dependencies(self) -> dict:
                return {
                    'document': self.document,
                    'config'  : self.config,
                }
        """
        return {}
```

**Location**: Add after the `resolve_args_and_kwargs` method (around line 165).

### 1.2 Modification to Task Class

**File**: `osbot_utils/helpers/flows/Task.py`

Modify `resolve_args_and_kwargs` to include flow-defined dependencies:

```python
def resolve_args_and_kwargs(self):
    dependency_manager = Dependency_Manager()
    dependency_manager.add_dependency('this_task', self               )
    dependency_manager.add_dependency('this_flow', self.task_flow     )
    dependency_manager.add_dependency('task_data', self.data          )
    dependency_manager.add_dependency('flow_data', self.task_flow.data)
    
    # NEW: Add flow-defined task dependencies
    for name, value in self.task_flow.task_dependencies().items():
        dependency_manager.add_dependency(name, value)
    
    self.resolved_args, self.resolved_kwargs = dependency_manager.resolve_dependencies(
        self.task_target, *self.task_args, **self.task_kwargs
    )
```

**Location**: Modify existing method (around line 73).

### 1.3 Backwards Compatibility

These changes are fully backwards compatible:
- `task_dependencies()` returns empty dict by default
- Existing flows continue to work unchanged
- Only flows that override `task_dependencies()` gain new behavior

---

## Part 2: New File Structure

### 2.1 Directory Layout

```
lets_pipeline/
└── lets/
    ├── __init__.py
    ├── actions/                              # NEW: Reusable action functions
    │   ├── __init__.py
    │   ├── load/
    │   │   ├── __init__.py
    │   │   ├── lets__action__load__passthrough.py
    │   │   ├── lets__action__load__from__cache_service.py
    │   │   └── lets__action__load__from__filesystem.py
    │   ├── extract/
    │   │   ├── __init__.py
    │   │   ├── lets__action__extract__passthrough.py
    │   │   └── lets__action__extract__unzip_content.py
    │   ├── transform/
    │   │   ├── __init__.py
    │   │   ├── lets__action__transform__passthrough.py
    │   │   ├── lets__action__transform__compute_stats.py
    │   │   └── lets__action__transform__html_to_dict.py
    │   └── save/
    │       ├── __init__.py
    │       ├── lets__action__save__passthrough.py
    │       ├── lets__action__save__to__cache_service.py
    │       └── lets__action__save__to__filesystem.py
    ├── base/
    │   ├── __init__.py
    │   ├── Html_LETS__Base.py                # REFACTORED: Uses Flow/Task
    │   ├── Html_LETS__Flow.py                # NEW: Extended Flow with typed deps
    │   └── Html_LETS__Executor.py            # KEEP: Orchestrates multiple steps
    ├── enums/
    │   ├── __init__.py
    │   └── Enum__Html_LETS__Type.py
    ├── safe_str/
    │   ├── __init__.py
    │   ├── Safe_Str__LETS__Name.py
    │   └── Safe_Str__LETS__Data_Key.py
    ├── schemas/
    │   ├── __init__.py
    │   ├── Schema__LETS__Config.py           # EXPANDED: More config options
    │   ├── Schema__LETS__Input.py
    │   ├── Schema__LETS__Output.py
    │   ├── Schema__LETS__Result.py
    │   └── Schema__LETS__Status.py
    └── steps/                                # RENAMED from implementations/
        ├── __init__.py
        ├── Html_LETS__Html__From__Raw.py     # REFACTORED: Declarative
        ├── Html_LETS__Html__To__Dict.py      # REFACTORED: Declarative
        └── Html_LETS__Dict__To__MGraph.py    # REFACTORED: Declarative
```

---

## Part 3: Core Components

### 3.1 Html_LETS__Flow (Extended Flow)

**File**: `lets/base/Html_LETS__Flow.py`

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Html_LETS__Flow - Extended Flow with LETS-specific typed dependencies
# Provides type-safe dependency injection for LETS actions
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.helpers.flows.Flow                                                     import Flow
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Config import Schema__LETS__Config
from mgraph_ai_service_html_graph.service.cache_storage.Html_Cache__Document            import Html_Cache__Document


class Html_LETS__Flow(Flow):
    """Flow extended with LETS-specific typed attributes for dependency injection."""
    
    document : Html_Cache__Document = None    # Cache document for storage operations
    config   : Schema__LETS__Config = None    # Step configuration
    
    def task_dependencies(self) -> dict:
        """Provide typed dependencies for automatic injection into tasks.
        
        Tasks can request these as parameters:
            @task()
            def my_action(input_data, document=None, config=None):
                # document and config are auto-injected
        """
        return {
            'document': self.document,
            'config'  : self.config  ,
        }
```

### 3.2 Html_LETS__Base (Refactored Base Class)

**File**: `lets/base/Html_LETS__Base.py`

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Html_LETS__Base - Base class for all LETS steps
# Uses Flow/Task system for execution with declarative action wiring
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.type_safe.Type_Safe                                                      import Type_Safe
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                            import type_safe
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.base.Html_LETS__Flow         import Html_LETS__Flow
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Config import Schema__LETS__Config
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Input  import Schema__LETS__Input
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Output import Schema__LETS__Output
from mgraph_ai_service_html_graph.service.cache_storage.Html_Cache__Document              import Html_Cache__Document


class Html_LETS__Base(Type_Safe):
    """Base class for LETS steps with declarative action wiring.
    
    Subclasses wire actions as class attributes:
        class My_Step(Html_LETS__Base):
            load      = lets__action__load__passthrough
            extract   = lets__action__extract__passthrough
            transform = lets__action__transform__my_transform
            save      = lets__action__save__to__cache_service
    """
    
    # Configuration
    config   : Schema__LETS__Config     = None    # Step configuration (set in setup)
    document : Html_Cache__Document     = None    # Cache document for storage
    
    # Execution state
    flow     : Html_LETS__Flow          = None    # Flow instance (exposed for observability)
    output   : Schema__LETS__Output     = None    # Final output after execution
    
    # Actions - override in subclasses
    load      : callable = None    # Load action
    extract   : callable = None    # Extract action  
    transform : callable = None    # Transform action
    save      : callable = None    # Save action
    
    def setup(self) -> 'Html_LETS__Base':
        """Initialize configuration. Override in subclasses."""
        raise NotImplementedError("Subclasses must implement setup()")
    
    @type_safe
    def execute(self, input_data: Schema__LETS__Input) -> Schema__LETS__Output:
        """Execute the L-E-T-S pipeline using Flow/Task orchestration.
        
        Args:
            input_data: Type-safe input for the step
            
        Returns:
            Type-safe output from the step
        """
        self._validate_actions()
        
        with Html_LETS__Flow() as flow:
            self.flow = flow
            
            # Inject typed dependencies
            flow.document = self.document
            flow.config   = self.config
            
            # Setup and execute
            flow.setup(self._run_pipeline, input_data)
            flow.execute()
            
            self.output = flow.flow_return_value
            return self.output
    
    def _validate_actions(self):
        """Ensure all L-E-T-S actions are wired."""
        missing = []
        if self.load      is None: missing.append('load')
        if self.extract   is None: missing.append('extract')
        if self.transform is None: missing.append('transform')
        if self.save      is None: missing.append('save')
        
        if missing:
            raise ValueError(f"Step {self.__class__.__name__} missing actions: {missing}")
    
    def _run_pipeline(self, input_data: Schema__LETS__Input) -> Schema__LETS__Output:
        """Execute L-E-T-S sequence. Same for all steps."""
        load_output      = self.load(input_data)
        extract_output   = self.extract(load_output)
        transform_output = self.transform(extract_output)
        save_output      = self.save(transform_output)
        return save_output
    
    # ═══════════════════════════════════════════════════════════════════════════
    # Observability (available after execute)
    # ═══════════════════════════════════════════════════════════════════════════
    
    def durations(self) -> dict:
        """Get timing information for all actions."""
        if self.flow:
            return self.flow.durations()
        return {}
    
    def captured_logs(self) -> list:
        """Get captured log messages."""
        if self.flow:
            return self.flow.captured_logs()
        return []
    
    def flow_data(self) -> dict:
        """Get flow execution data for debugging."""
        if self.flow:
            return self.flow.json()
        return {}
```

### 3.3 Schema__LETS__Config (Expanded)

**File**: `lets/schemas/Schema__LETS__Config.py`

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Schema__LETS__Config - Configuration for a LETS step
# Includes action-specific configuration options
# ═══════════════════════════════════════════════════════════════════════════════

from typing                                                                             import Type
from osbot_utils.type_safe.Type_Safe                                                    import Type_Safe
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text            import Safe_Str__Text
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.safe_str.Safe_Str__LETS__Name import Safe_Str__LETS__Name
from mgraph_ai_service_html_graph.service.cache_storage.safe_str.Safe_Str__Layer_Name   import Safe_Str__Layer_Name
from mgraph_ai_service_html_graph.service.cache_storage.safe_str.Safe_Str__Data_File_Id import Safe_Str__Data_File_Id


class Schema__LETS__Config(Type_Safe):
    """Configuration for a LETS step and its actions."""
    
    # Identity
    name           : Safe_Str__LETS__Name = None    # Unique step name (e.g., 'html-from-raw')
    description    : Safe_Str__Text       = None    # Human-readable description
    
    # Schema types (optional, for validation)
    schema__input  : Type[Type_Safe]      = None    # Expected input schema type
    schema__output : Type[Type_Safe]      = None    # Expected output schema type
    
    # Save action configuration
    save_layer     : Safe_Str__Layer_Name   = None  # Layer name for cache storage
    save_file_id   : Safe_Str__Data_File_Id = None  # File ID within layer
    save_type      : str                    = 'string'  # 'string' or 'json'
    
    # Load action configuration  
    load_layer     : Safe_Str__Layer_Name   = None  # Layer to load from
    load_file_id   : Safe_Str__Data_File_Id = None  # File ID to load
    
    # Transform configuration (step-specific, can be extended)
    compute_stats  : bool = True                    # Whether to compute statistics
```

---

## Part 4: Action Implementation

### 4.1 Action Naming Convention

```
lets__action__{phase}__{description}

Examples:
- lets__action__load__passthrough
- lets__action__load__from__cache_service
- lets__action__extract__passthrough
- lets__action__transform__compute_stats
- lets__action__transform__html_to_dict
- lets__action__save__to__cache_service
- lets__action__save__to__filesystem
```

### 4.2 Action Template

Each action follows this pattern:

```python
# ═══════════════════════════════════════════════════════════════════════════════
# lets__action__{phase}__{description} - Description of what it does
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.helpers.flows.decorators.task                                          import task
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                          import type_safe
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Config import Schema__LETS__Config
from mgraph_ai_service_html_graph.service.cache_storage.Html_Cache__Document            import Html_Cache__Document
# ... other imports for input/output schemas


@task()
@type_safe
def lets__action__{phase}__{description}(
    input_data : Schema__Input__Type,                    # Typed input from previous phase
    document   : Html_Cache__Document = None,            # Auto-injected via task_dependencies
    config     : Schema__LETS__Config = None,            # Auto-injected via task_dependencies
) -> Schema__Output__Type:
    """Description of what this action does.
    
    Args:
        input_data: Description of input
        document: Cache document (auto-injected)
        config: Step configuration (auto-injected)
        
    Returns:
        Typed output for next phase
    """
    # Implementation here
    return Schema__Output__Type(...)
```

### 4.3 Example Actions

#### lets__action__load__passthrough.py

```python
# ═══════════════════════════════════════════════════════════════════════════════
# lets__action__load__passthrough - Pass input through unchanged
# Used when no loading/fetching is needed
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.helpers.flows.decorators.task                                            import task
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                            import type_safe
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Input  import Schema__LETS__Load__Input
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Output import Schema__LETS__Load__Output


@task()
@type_safe
def lets__action__load__passthrough(
    input_data : Schema__LETS__Load__Input,
) -> Schema__LETS__Load__Output:
    """Pass input through unchanged.
    
    Simple passthrough for steps that receive data directly
    rather than loading from an external source.
    """
    return Schema__LETS__Load__Output(html=input_data.html)
```

#### lets__action__extract__passthrough.py

```python
# ═══════════════════════════════════════════════════════════════════════════════
# lets__action__extract__passthrough - Pass data through unchanged
# Used when no extraction/filtering is needed
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.helpers.flows.decorators.task                                            import task
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                            import type_safe
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Input  import Schema__LETS__Extract__Input
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Output import Schema__LETS__Extract__Output


@task()
@type_safe
def lets__action__extract__passthrough(
    input_data : Schema__LETS__Load__Output,              # Output from Load phase
) -> Schema__LETS__Extract__Output:
    """Pass data through unchanged.
    
    Simple passthrough for steps that don't need to
    extract or filter data before transformation.
    """
    return Schema__LETS__Extract__Output(html=input_data.html)
```

#### lets__action__transform__compute_stats.py

```python
# ═══════════════════════════════════════════════════════════════════════════════
# lets__action__transform__compute_stats - Compute HTML statistics
# Calculates character count, tag count, and other metrics
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.helpers.flows.decorators.task                                            import task
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                            import type_safe
from osbot_utils.type_safe.primitives.core.Safe_Int                                       import Safe_Int
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Config import Schema__LETS__Config
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Output import Schema__LETS__Extract__Output
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Output import Schema__LETS__Transform__Output


@task()
@type_safe
def lets__action__transform__compute_stats(
    input_data : Schema__LETS__Extract__Output,
    config     : Schema__LETS__Config = None,
) -> Schema__LETS__Transform__Output:
    """Compute statistics about HTML content.
    
    Calculates:
    - Character count
    - Tag count (approximate)
    - Line count
    """
    html = str(input_data.html)
    
    stats = {
        'char_count': len(html),
        'tag_count' : html.count('<'),
        'line_count': html.count('\n') + 1,
    }
    
    return Schema__LETS__Transform__Output(
        html  = input_data.html,
        stats = stats,
    )
```

#### lets__action__save__to__cache_service.py

```python
# ═══════════════════════════════════════════════════════════════════════════════
# lets__action__save__to__cache_service - Save content to cache storage
# Stores data in a cache layer using the cache service
# ═══════════════════════════════════════════════════════════════════════════════

from osbot_utils.helpers.flows.decorators.task                                            import task
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                            import type_safe
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Config import Schema__LETS__Config
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Output import Schema__LETS__Transform__Output
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Output import Schema__LETS__Save__Output
from mgraph_ai_service_html_graph.service.cache_storage.Html_Cache__Document              import Html_Cache__Document


@task()
@type_safe
def lets__action__save__to__cache_service(
    input_data : Schema__LETS__Transform__Output,
    document   : Html_Cache__Document = None,
    config     : Schema__LETS__Config = None,
) -> Schema__LETS__Save__Output:
    """Save content to cache storage layer.
    
    Uses config.save_layer and config.save_file_id to determine
    where to store the content. Supports string and JSON formats.
    """
    if document is None:
        # No document = stateless execution, skip save
        return Schema__LETS__Save__Output(success=True, cached=False)
    
    layer = document.layer(layer_name=config.save_layer)
    
    if config.save_type == 'json':
        layer.save_json(file_id=config.save_file_id, content=input_data.html)
    else:
        layer.save_string(file_id=config.save_file_id, content=str(input_data.html))
    
    return Schema__LETS__Save__Output(
        success = True,
        cached  = True,
        layer   = config.save_layer,
        file_id = config.save_file_id,
    )
```

---

## Part 5: Refactored Step Implementation

### 5.1 Html_LETS__Html__From__Raw (Declarative)

**File**: `lets/steps/Html_LETS__Html__From__Raw.py`

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Html_LETS__Html__From__Raw - LETS step for receiving raw HTML input
# First step in most pipelines - receives and stores raw HTML
# ═══════════════════════════════════════════════════════════════════════════════

from mgraph_ai_service_html_graph.service.lets_pipeline.lets.base.Html_LETS__Base           import Html_LETS__Base
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Config   import Schema__LETS__Config
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.safe_str.Safe_Str__LETS__Name  import Safe_Str__LETS__Name
from mgraph_ai_service_html_graph.service.cache_storage.safe_str.Safe_Str__Layer_Name       import Safe_Str__Layer_Name
from mgraph_ai_service_html_graph.service.cache_storage.safe_str.Safe_Str__Data_File_Id     import Safe_Str__Data_File_Id

# Import reusable actions
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.actions.load.lets__action__load__passthrough           import lets__action__load__passthrough
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.actions.extract.lets__action__extract__passthrough     import lets__action__extract__passthrough
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.actions.transform.lets__action__transform__compute_stats import lets__action__transform__compute_stats
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.actions.save.lets__action__save__to__cache_service     import lets__action__save__to__cache_service


class Html_LETS__Html__From__Raw(Html_LETS__Base):
    """LETS step for receiving raw HTML input.
    
    Pipeline:
    - Load: Passthrough (HTML provided directly)
    - Extract: Passthrough (no extraction needed)
    - Transform: Compute statistics
    - Save: Store in cache layer 'raw-html'
    """
    
    # Declarative action wiring
    load      = lets__action__load__passthrough
    extract   = lets__action__extract__passthrough
    transform = lets__action__transform__compute_stats
    save      = lets__action__save__to__cache_service
    
    def setup(self) -> 'Html_LETS__Html__From__Raw':
        """Initialize step configuration."""
        self.config = Schema__LETS__Config(
            name         = Safe_Str__LETS__Name('html-from-raw'),
            description  = 'Load raw HTML and store in cache',
            save_layer   = Safe_Str__Layer_Name('raw-html'),
            save_file_id = Safe_Str__Data_File_Id('source'),
            save_type    = 'string',
            compute_stats = True,
        )
        return self
```

### 5.2 Usage Example

```python
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.steps.Html_LETS__Html__From__Raw import Html_LETS__Html__From__Raw
from mgraph_ai_service_html_graph.service.lets_pipeline.lets.schemas.Schema__LETS__Input import Schema__LETS__Load__Input
from mgraph_ai_service_html_graph.service.cache_storage.Html_Cache__Document import Html_Cache__Document

# Setup
document = Html_Cache__Document(client=cache_client, namespace='test', cache_key='my/doc')
document.ensure_cache_id()

# Create and execute step
step = Html_LETS__Html__From__Raw(document=document).setup()
input_data = Schema__LETS__Load__Input(html='<html><body>Hello</body></html>')
result = step.execute(input_data)

# Access results
print(result)                    # Schema__LETS__Save__Output
print(step.output)               # Same as result
print(step.durations())          # {'flow_duration': 0.01, 'tasks': [...]}
print(step.captured_logs())      # ['Executing task...', ...]
```

---

## Part 6: Testing Strategy

### 6.1 Unit Tests for Actions

Each action should be tested independently:

```python
class test_lets__action__load__passthrough(TestCase):
    
    def test__basic_passthrough(self):
        """Test that input passes through unchanged."""
        # Actions need a Flow context to run
        @flow()
        def test_flow():
            input_data = Schema__LETS__Load__Input(html='<html></html>')
            return lets__action__load__passthrough(input_data)
        
        result = test_flow().execute()
        output = result.flow_return_value
        
        assert type(output)  is Schema__LETS__Load__Output
        assert output.html   == '<html></html>'
```

### 6.2 Integration Tests for Steps

```python
class test_Html_LETS__Html__From__Raw(TestCase):
    
    @classmethod
    def setUpClass(cls):
        cls.html_cache_client, cls.cache_service = create_html_cache_client()
        cls.html_gen = Html_Generator__For_Tests()
    
    def test__execute__full_pipeline(self):
        """Test complete L-E-T-S execution."""
        document = Html_Cache__Document(
            client    = self.html_cache_client,
            namespace = 'test',
            cache_key = 'test/html-from-raw',
        )
        document.ensure_cache_id()
        
        step = Html_LETS__Html__From__Raw(document=document).setup()
        html = self.html_gen.simple_html()
        
        result = step.execute(Schema__LETS__Load__Input(html=html))
        
        assert result.success is True
        assert result.cached  is True
        assert step.durations() is not None
    
    def test__execute__stateless(self):
        """Test execution without document (stateless)."""
        step = Html_LETS__Html__From__Raw().setup()  # No document
        html = self.html_gen.minimal_html()
        
        result = step.execute(Schema__LETS__Load__Input(html=html))
        
        assert result.success is True
        assert result.cached  is False  # No document = no caching
```

---

## Part 7: Migration Guide

### 7.1 Steps to Migrate Existing Step

1. **Identify L-E-T-S phases** - What does each phase actually do?

2. **Find or create actions** - Check if reusable actions exist, create if needed

3. **Refactor to declarative** - Wire actions as class attributes

4. **Update setup()** - Configure save_layer, save_file_id, etc.

5. **Update tests** - Use `step.execute(input)` pattern

### 7.2 Before/After Comparison

**Before (Manual Wiring):**
```python
class Html_LETS__Html__From__Raw(Html_LETS__Base):
    
    def load(self, load_input):
        return Schema__Load__Output(html=load_input.html)
    
    def extract(self, extract_input):
        return extract_input
    
    def transform(self, transform_input):
        # ... implementation ...
        return Schema__Transform__Output(...)
    
    def save(self, save_input):
        # ... implementation ...
        return Schema__Save__Output(success=True)
```

**After (Declarative):**
```python
class Html_LETS__Html__From__Raw(Html_LETS__Base):
    
    load      = lets__action__load__passthrough
    extract   = lets__action__extract__passthrough
    transform = lets__action__transform__compute_stats
    save      = lets__action__save__to__cache_service
    
    def setup(self):
        self.config = Schema__LETS__Config(
            name         = 'html-from-raw',
            save_layer   = 'raw-html',
            save_file_id = 'source',
        )
        return self
```

---

## Part 8: Benefits Summary

| Aspect | Before | After |
|--------|--------|-------|
| **Code in step** | 50+ lines per phase | 4 lines (action wiring) |
| **Reusability** | Copy/paste | Import and wire |
| **Observability** | Manual logging | Automatic via Flow |
| **Timing** | Manual | `step.durations()` |
| **Error handling** | Manual try/catch | `@task(raise_on_error=...)` |
| **Testing** | Test whole step | Test actions independently |
| **Type safety** | Varies | Enforced via schemas |
| **Configuration** | Scattered | Centralized in config |

---

## Part 9: Implementation Order

1. **Phase 1: osbot_utils changes**
   - Add `task_dependencies()` to Flow
   - Modify Task to use `task_dependencies()`
   - Add tests

2. **Phase 2: Core infrastructure**
   - Create `Html_LETS__Flow`
   - Refactor `Html_LETS__Base`
   - Expand `Schema__LETS__Config`

3. **Phase 3: Create base actions**
   - `lets__action__load__passthrough`
   - `lets__action__extract__passthrough`
   - `lets__action__transform__passthrough`
   - `lets__action__save__to__cache_service`

4. **Phase 4: Migrate steps**
   - `Html_LETS__Html__From__Raw`
   - `Html_LETS__Html__To__Dict`
   - `Html_LETS__Dict__To__MGraph`

5. **Phase 5: Additional actions**
   - `lets__action__transform__compute_stats`
   - `lets__action__transform__html_to_dict`
   - `lets__action__load__from__cache_service`
   - etc.

---

## Appendix A: Quick Reference

### Injectable Dependencies (via task_dependencies)

| Parameter | Type | Source |
|-----------|------|--------|
| `document` | `Html_Cache__Document` | `Html_LETS__Flow.document` |
| `config` | `Schema__LETS__Config` | `Html_LETS__Flow.config` |
| `this_flow` | `Html_LETS__Flow` | Built-in (Task) |
| `this_task` | `Task` | Built-in (Task) |
| `flow_data` | `dict` | Built-in (Flow) |
| `task_data` | `dict` | Built-in (Task) |

### Action Phases

| Phase | Input | Output | Purpose |
|-------|-------|--------|---------|
| Load | `Schema__LETS__Load__Input` | `Schema__LETS__Load__Output` | Fetch/receive data |
| Extract | `Schema__LETS__Load__Output` | `Schema__LETS__Extract__Output` | Filter/extract |
| Transform | `Schema__LETS__Extract__Output` | `Schema__LETS__Transform__Output` | Process/convert |
| Save | `Schema__LETS__Transform__Output` | `Schema__LETS__Save__Output` | Persist/store |
